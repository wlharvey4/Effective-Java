# -*- mode:org; fill-column:79; -*-
#+TITLE: Effective Java
#+SUBTITLE: Best Practices for the Java Platform (3rd Edition)
#+AUTHOR: Joshua Bloch
#+SUBAUTHOR: Outline by WLHarvey4
#+DATE: 2019-01-24 Thu 10:14
#+MACRO: VERSION Version 0.0.3
#+MACRO: EDITION Outline Edition 0.1
#+CREATOR: WLHarvey4

#+TEXINFO: @insertcopying

* Forward by Guy L. Steele, Jr.
  :PROPERTIES:
  :UNNUMBERED:
  :END:
  There are three things one must master to learn to use a new language outside
  of the classroom:

  1. *Grammer*: how the language is /structured/;
  2. *Vocabulary*: how to name things you want to talk about;
  3. *Usage*: the customary and effective ways to say everyday things.


  It is much the same with programming languages.

  - one needs to understand the core language: is it
    - algorithmic,
    - functional,
    - object-oriented?

  - one needs to know the vocabulary:
    - what data structures,
    - operations,
    - facilities
    are provided by the standard libraries?

  And one needs to be familiar with the customary and effective ways to
  structure code.


  {{{heading(On Usage)}}}

  Books about programming languages often cover only the first two or discuss
  usage only spottily.  Maybe that's because the first two are in some ways
  easier to write about.  Grammar and vocabulary are properties of the language
  alone, but *usage* is characteristic of a community that uses it.

  The Java programming language, for example, is:

  - object-oriented
  - with single inheritance
  - and supports an imperative (statement-oriented) coding style within each
    method.
  - The libraries address graphic display support,
  - networking,
  - distributed computing, and
  - security.

  But /how/ is the language best put to use /in practice/?

  {{{heading(On Change)}}}

  There is another point.  Programs, unlike spoken sentences and unlike most
  books and magazines, are likely to be changed over time.  It's typically not
  enough to produce code that operates effectively and is readily understood by
  other persons; *one must also organize the code so that it is easy to
  modify.* There may be ten ways to write code for some task /T/.  Of those ten
  ways, seven will be awkward, inefficent, or puzzling.  Of the other other
  three, which is most likely to be similar to the code needed for the task
  /T2/ in next year's software release?

  {{{heading(Books on Grammar and Libraries)}}}

  There are numerous books from which you can learn the grammar of the Java
  programming language, including:

  - {{{cite(The Java Programming Language)}}} by Arnold, Gosling, and Holmes; or
  - {{{cite(The Java Language Specification)}}} by Gosling, Joy, Steele, and
    Bracha.


  Likewise, there are dozens of books on the libraries and APIs associated with
  the Java programming language.

  {{{heading(Customary and Effective Usage)}}}

  This book addresses your third need: /customary and effective usage/.  Joshua
  Bloch has spent years extending, implementing, and using the Java programming
  language at Sun Microsystems; he has also read a log of other people's code,
  including Steele's.,  Here he offers good advice, systematically organized,
  on how to structure your code so that:

  - it works well
  - other people can understand it,
  - future modifications and improvements are less likely to cause headaches;
  - (hopefully) your programs will be pleasant, elegant, and graceful.


  {{{noindent}}}--- Guy L. Steele Jr. (April 2001)

* Preface
  :PROPERTIES:
  :UNNUMBERED:
  :END:

** Preface to the Third Edition

   #+cindex: Gosling, James
   #+cindex: Stroustrup, Bjarne
   #+cindex: C++
   In 1997, when Java was new, James Gosling (the father of Java), described it
   as a ``blue collar language'' that was ``pretty simple''.  At about the same
   time, Bjarne Stroustrup (the father of C++) described C++ as a
   ``multi-paradigm language'' that ``deliberately differs from languages
   designed to support a single way of writing programs.''  Stroustrup warned:

   #+BEGIN_QUOTE
   Much of the relative simplicity of Java is --- like most new languages ---
   partly an illusion and partly a function of its incompleteness.  As time
   passes, Java will grow significantly in size and complexity.  It will double
   or triple in size and grow implementation-dependent extensions or libraries.

   ---Stroustrup
   #+END_QUOTE

   Twenty years later, it's fair to say that Gosling and Stroustrup were both
   right.  Java is now large and complex, with multiple abstractions for many
   things, from parallel execution, to iteration, to the representation of
   dates and times.

   Joshua Bloch still likes Java, but his ardor has cooled a bit as the
   platform has grown.  Given its increased size and complexity, the need for
   an up-to-date best practices guide is all the more critical.  With this
   third edition of {{{cite({{{title}}})}}}, the author, Bloch, did his best to
   provide one.

   Small is beautiful, but simple ain't easy.

   {{{noindent}}}--- Joshua Bloch, November 2017

** Preface to the Second Edition

   #+cindex: changes since 2001
   #+cindex: Java 5
   A lot has happened since the first edition in 2001.  The most significant
   set of changes was:

   - the addition of
     - generics
     - enum types
     - annotations
     - autoboxing
     - ~for-each~ loop in Java 5.


   A close second was:

   #+cindex: concurrency library
   #+cindex: Java 5
   - the addition of the new concurrency library,
     {{{code(java.util.concurrent)}}}, also released in Java 5.


   #+cindex: Bracha, Gilad
   #+cindex: Lea, Doug
   Bloch lead the teams (with Gilad Bracha) that designed the new language
   features.  Bloch also served on the team that designed and developed the
   concurrency library, led by Doug Lea.

   #+cindex: IDEs
   The other big change in the platform is

   #+cindex: Eclipse
   #+cindex: IntelliJ IDEA
   #+cindex: NetBeans
   #+cindex: static analysis tools
   #+cindex: tools, static analysis
   #+cindex: FindBugs
   - the widespread adoption of modern Integrated Development Environments
     (IDE's), such as
     - Eclipse
     - IntelliJ IDEA
     - NetBeans
   - and of static analysis tools such as:
     - FindBugs


   #+cindex: Sun
   #+cindex: Google
   #+cindex: concurrency API
   #+cindex: collections API
   #+cindex: APIs
   #+cindex: Java Community Process
   In 2004 Bloch moved from Sun to Google, but he's continued his involvement
   in the development of the Java platform over the past four years,
   contributing to the concurrency and collections APIs through the good
   offices of Google and the Java Community Process.  He has also used the Java
   platform to develop libraries for use within Google.  He now knows what it
   is like to be a /user/.

   His primary goal is to share his experience with the reader so that the
   reader can imitate his successes while avoiding his failures.  The new
   material continues to make liberal use of the real-world examples from the
   Java platform libraries.

   The material in this edition has grown from fifty-seven items to
   seventy-eight.  He also thoroughly revised all the original material and
   retired a few items.  In the Appendix you can see how the material in this
   edition relates to the material in the first edition.

   The changes in releases 5 and 6 have taken a good thing and made it better.
   The platform is much bigger now that it was in 2001 and more complex, but
   once you learn the patterns and idioms for using the new features, they make
   your programs better and your life easier.

   {{{noindent}}}--- Joshua Bloch, April 2008

** Preface to the First Edition

   #+cindex: JavaSoft
   In 1996 Joshua Bloch went to work for JavaSoft, as it was then known.  In
   the intervening five years he has served as Java platform libraries
   architect.  He has designed, implemented, and maintained many of the
   libraries and served as a consultant for many others.  Presiding over these
   libraries as the Java platform matures was a once-in-a-lifetime
   opportunity.  He worked with some of the great software engineers of our
   generation.  In the process he learned a lot about the Java programming
   language---what works, what doesn't, and how to use the language and its
   libraries to best effort.

   #+cindex: Meyer, Scott
   #+cindex: @cite{Effective C++}
   This book is his attempt to share his experience with the reader so that the
   reader can imitate his successes while avoiding his failures,.  He borrowed
   the format from Scott Meyer's {{{cite(Effective C++)}}}, which consists of
   fifty items, each conveying one specific rule for improving programs and
   designs.  He found the format to be singularly effective.  He hopes you do
   too.

   He took the liberty of illustrating the items with real-world examples from
   the Java platform libraries.  When describing something that could have been
   done better, he tried to pick on code that he wrote himself, but
   occasionally he picks on something written by a colleague.  Negative
   examples are cited not to cast blame but in the spirit of cooperation, so
   that all of us can benefit from the experience of those who've gone before.

   #+cindex: reusable components
   #+cindex: exported APIs
   While this book is not targeted solely at developers of reusable components,
   it is inevitably colored by Bloch's experience writing such components over
   the past two decades.  He naturally thinks in terms of exported APIs, and he
   encourages the reader to do likewise.  Even if you are not developing
   reusable components, thinking in these terms tends to improve the quality of
   the software you write.  Furthermore, its not uncommon to write reusable
   components without knowing it.  You write something useful, share it with
   your buddy, and before long you have half a dozen users.  At this point, you
   no longer have the flexibility to change the API at will and are thankful
   for all the effort you put into designing the API when you first wrote the
   software.

   #+cindex: extreme programming
   #+cindex: software development methodologies
   #+cindex: API design
   #+cindex: refactoring process, goals
   Bloch's focus on API design may seem a bit unnatural to devotees of the new
   lightweight software development methodologies , such as /Extreme
   Programming/.  These methodologies emphasize writing the simplest program
   that could possibly work.  If you are using one of these methodologies, you
   will find that a focus on API design serves you well in the /refactoring/
   process.  The fundamental goals of refactoring are the improvement of system
   structure and the avoidance of code duplication.  These goals are impossible
   to achieve in the absence of well-designed APIs for the components of the
   system.

   No language is perfect, but some are excellent.  Bloch has found the Java
   programming language and its libraries to be immensely conducive to quality
   and productivity, and a joy to work with.

   {{{noindent}}}--- Joshua Bloch, April 2001

* Introduction

  This book is designed to help you make effective use of the Java programming
  language and its fundamental libraries and some subpackages:

  #+cindex: @code{java.lang}
  #+cindex: @code{java.util}
  #+cindex: @code{java.util.concurrent}
  #+cindex: @code{java.util.function}
  #+cindex: @code{java.io}
  - ~java.lang~
  - ~java.util~
    - ~java.util.concurrent~
    - ~java.util.function~
  - ~java.io~


  #+cindex: software design, rules
  This book consists of ninety items, each of which conveys one rule.  The
  rules capture practices generally held to be beneficial by the best and most
  experienced programmers.  The items are loosely grouped into eleven chapters,
  each covering one broad aspect of software design.  The book is not intended
  to be read from cover to cover: each item stands on its own, more or less.
  The items are heavily cross-referenced so you can easily plot your own course
  through the book.

** New Features Since Prior Edition

  #+cindex: new features
  Many new features were added to the platform since the last edition.  Most of
  the items in this book use these features in some way.  This table shows you
  where to go for primary coverage of key features:

  #+NAME: tbl:new-features
  #+CAPTION: List of New Features
  #+ATTR_TEXINFO: :columns .5 .25 .25
| Feature                       | Items        | Release |
|-------------------------------+--------------+---------|
| Lambdas                       | Items 42--44 | Java 8  |
| Streams                       | Items 45--48 | Java 8  |
| Optionals                     | Item 55      | Java 8  |
| Default methods in interfaces | Item 21      | Java 8  |
| ~try-with-resources~          | Item 9       | Java 7  |
| ~@SafeVarargs~                | Item 32      | Java 7  |
| Modules                       | Item 15      | Java 9  |
|-------------------------------+--------------+---------|


** Program Examples and Antipatterns

  #+cindex: program examples
  #+cindex: examples, program or code
  #+cindex: code examples
  #+cindex: @cite{Design Patterns: Elements of Reusable Object-Oriented Software}
  #+cindex: Gamma Helm Johnson Vlissides
  Most items are illustrated with program examples.  A key feature of the book
  is that it contains code examples illustrating many design patterns and
  idioms.  Where appropriate, they are cross-referenced to the standard
  reference work in this area: {{{cite(Design Patterns)}}} (Gamma et al.).

  {{{subheading(Antipatterns)}}}

  #+cindex: antipatterns
  Many items contain one or more program examples illustrating some practice to
  be avoided.  Such examples, sometimes known as /antipatterns/, are clearly
  labeled with a comment such as ~// Never do this!~.  In each case, the item
  explains why the example is bad and suggests an alternative approach.

** Intended Audience

  This book is not for beginners: it assumes that you are already comfortable
  with Java.  If you are not, consider one fo the many fine introductory texts,
  such as Peter Sestoft's {{{cite(Java Precisely)}}}.  While
  {{{cite({{{title}}})}}} is designed to be accessible to anyone with a working
  knowledge of the language, it should provide food for thought even for
  advanced programmers.

** Rules Derived from Fundamental Principles

  #+cindex: fundamental principles
  #+cindex: principles, fundamental
  #+cindex: rules
  #+cindex: component, definition
  Most of the rules in this book derive from a few fundamental principles.

  - Clarity and simplicity are of paramount importance.
  - The user of a component should never be surprised by its behavior.
  - Components should be as small as possible but no smaller. [fn:component]
  - Code should be reused rather than copied.
  - The dependencies between components should be kept to a minimum.
  - Errors should be detected as soon as possible after they are made, ideally
    at compile time.


  {{{subheading(The Art of Programming is Learning to Break the Rules)}}}

  #+cindex: best programming practices
  While the rules in this book do not apply 100 percent of the time, they do
  characterize best programming practices in the great majority of cases.  You
  should not slavishly follow these rules, but violate them only occasionaly
  and with good reason.  Learning the art of programming, like most
  disciplines, consists of learning the rules and then learning when to break
  them.

** On Performance Issues in this Book

  #+cindex: performance
  #+cindex: programming objectives
  For the most part, this book is not about *performance*.  It is about writing
  programs that are:

  - clear
  - correct
  - usable
  - robust
  - flexible
  - maintainable


  {{{noindent}}}If you can do that, it's usually a relatively simple matter to
  get the performance you need.
  - [ ] Link to Item 67 here


  #+cindex: ``on my machine''
  #+cindex: performance numbers
  {{{noindent}}}Some items do discuss performance concerns, and a few of these
  items provide performance numbers.  These numbers, which are introduced with
  the phrase ``On my machine,'' should be ragarded as approximate at best.

** Releases and Names

  When discussing features of the Java programming language and its libraries,
  it is sometimes necessary to refer to specific releases.  For convenience,
  this book uses nicknames in preference to official release names.  This table
  shows the mapping between release names and nicknames.

  #+NAME: tbl:release-nickname
  #+CAPTION: Official Release Name to Nickname
  | Official Release Name                  | Nickname |
  |----------------------------------------+----------|
  | JDK 1.0.x                              | Java 1.0 |
  | JDK 1.1.x                              | Java 1.1 |
  | Java 2 Platform, Standard Edition v1.2 | Java 2   |
  | Java 2 Platform, Standard Edition v1.3 | Java 3   |
  | Java 2 Platform, Standard Edition v1.4 | Java 4   |
  | Java 2 Platform, Standard Edition v5.0 | Java 5   |
  | Java Platform, Standard Edition 6      | Java 6   |
  | Java Platform, Standard Edition 7      | Java 7   |
  | Java Platform, Standard Edition 8      | Java 8   |
  | Java Platform, Standard Edition 9      | Java 9   |
  |----------------------------------------+----------|


** Example Programs

  #+cindex: examples
  #+cindex: @code{java.util}
  #+cindex: @code{java.io}
  The examples are reasonably complete, but favor readability over
  completeness.  They freely use classes from packages:

  - ~java.util~
  - ~java.io~


  {{{subheading(Compiling Example Programs)}}}

  #+cindex: compile examples
  #+cindex: examples, compile
  #+cindex: book website
  #+cindex: website, book's
  #+cindex: examples, extended versions
  In order to compile examples, you may have to add one or more import
  declarations, or other such boilerplate.  The book's website,
  [[http://joshbloch.com/effectdivejava/]], contains an expanded version of each
  example, which you can compile and run.

** Technical Terms Old and New

  #+cindex: terms, technical
  #+cindex: technical terms
  #+cindex: @cite{The Java Language Specification, Java SE 8 Edition}
  For the most part, this book uses technical terms as theyare defined the
  {{{cite(The Java Language Specification, Java SE 8 Edition)}}}.  A few terms
  deserve special mention.

  {{{subheading(Types)}}}

  #+cindex: types, four
  #+cindex: interfaces
  #+cindex: annotations
  #+cindex: classes
  #+cindex: enums
  #+cindex: arrays
  #+cindex: primitives
  #+cindex: term, types
  #+cindex: term, interfaces
  #+cindex: term, classes
  #+cindex: term, arrays
  #+cindex: term, primitives
  - The language supports four kinds of /types/:
    - /interfaces/ (including /annotations/)
    - /classes/ (including /enums/)
    - /arrays/
    - /primitives/

  {{{subheading(Reference Types)}}}

  #+cindex: reference types
  #+cindex: objects
  #+cindex: members
  #+cindex: fields
  #+cindex: methods
  #+cindex: member classes
  #+cindex: member interfaces
  #+cindex: term, reference types
  #+cindex: term, objects
  #+cindex: term, members
  #+cindex: term, fields
  #+cindex: term, methods
  #+cindex: term, member interfaces
  The first three are known as /reference types/.  Class instances and arrays
  are /objects/; primitive values are not.  A Class's /members/ consist of of
  its:
  - /fields/
  - /methods/
  - /member classes/
  - /member interfaces/

  {{{subheading(Method Signature)}}}

  #+cindex: signature
  #+cindex: return type
  #+cindex: term, signature
  A method's /signature/ consists of its name and the types of its formal
  parameters; the signature does /not/ include the method's return type.

  {{{subheading(Old Terms with New Meanings)}}}

  #+cindex: @cite{Java Language Specification}
  #+cindex: inheritance
  #+cindex: subclassing
  #+cindex: implements an interface
  #+cindex: extends an interface
  #+cindex: access level
  #+cindex: package-private
  #+cindex: package access
  #+cindex: term, inheritance
  #+cindex: term, subclassing
  #+cindex: term, implements
  #+cindex: term, extends
  #+cindex: term, package-private
  #+cindex: term, package access
  This book uses a few terms differently than the {{{cite(Java Language
  Specification)}}}.  Unlike that reference, this book uses /inheritance/ as a
  synonym for /subclassing/.  Instead of the term inheritance for interfaces,
  this book simply states that a class /implements/ an interface or that one
  interface /extends/ another.  To describe the access level that applies when
  none is specified, this book uses the traditional /package-private/ instead
  of the technically correct /package access/.

  {{{subheading(New Defined Technical Terms)}}}

  #+cindex: @cite{The Java Language Specification}
  #+cindex: API
  #+cindex: exported API
  #+cindex: user of API
  #+cindex: API user
  #+cindex: client of API
  #+cindex: API client
  This book uses a few technical terms that are not defined in {{{cite(The Java
  Language Specification)}}}.  The term /exported API/, or simply /API/, refers
  to the classes, interfaces, constructors, members, and serialized forms by
  which a programmer accesses a class, interface, or package. [fn:API] A
  programmer who writes a program that uses an API is referred to as a /user/
  of the API.  A class whose implementation uses an API is a /client/ of the
  API.

** Exported APIs

  #+cindex: exported API
  #+cindex: API, exported
  #+cindex: API elements
  #+cindex: term, API elements
  #+cindex: Javadoc utility
  #+cindex: utility, Javadoc
  Classes, interfaces, constructors, members and serialized forms are
  collectively known as /API elements/.  An exported API consists of the API
  elements that are accessible outside of the package that defines the API.
  These are the API elements that any client can use and the author of the API
  commits to support.  They are also the elements for which the Javadoc utility
  generates documentation in its default mode of operation.  The exported API
  of a package consists of the public and protected members and constructors of
  every public class or interface in the package.

  {{{subheading(Module System)}}}

  #+cindex: module system
  #+cindex: term, module system
  #+cindex: exported API, module
  In Java 9, a /module system/ was added to the platform.  If a library makes
  use of the module system, its exported API is the union of the exported APIs
  of all the packages exported by the library's module declaration.

[fn:component] The term /component/ refers to any reusable software element,
from an individual method to a complex framework consisting of multiple
packages.

[fn:API] The term /API/, which is short for /application programming
interface/, is used in preference to the otherwise preferable term /interface/
to avoid confusion with the language construct of that name.
* Lists
  :PROPERTIES:
  :APPENDIX: t
  :END:

** Tables

   #+TEXINFO: @listoffloats Table

* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:

* COPYING
  :PROPERTIES:
  :COPYING:
  :END:

  Outline of {{{cite({{{title}}})}}} by WLHarvey4

  Book \copy 2018 Pearson Education Inc.{{{break}}}
  Portions copyright \copy 2001-2008 Oracle and/or its affiliates.

  #+BEGIN_QUOTE
  {{{cite({{{title}}} (Third Edition))}}} by {{{author}}}.{{{break}}}
  All Rights Reserved.
  #+END_QUOTE

* SOURCE CODE SETTINGS                                             :noexport:

#+PROPERTY: header-args :export both
#+PROPERTY: header-args :python python3

* TEXINFO EXPORT SETTINGS                                          :noexport:

#+TEXINFO_PRINTED_TITLE: Outline of Effective Java
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+TEXINFO_DIR_CATEGORY: Java
#+TEXINFO_DIR_TITLE: Effective Java
#+TEXINFO_DIR_DESC: Outline of Effecive Java 3rd Edition by Joshua Bloch

* MACRO DEFINITIONS                                                :noexport:

#+MACRO: heading @@texinfo:@heading @@$1
#+MACRO: subheading @@texinfo:@subheading @@$1
#+MACRO: cite @@texinfo:@cite{@@$1@@texinfo:}@@
#+MACRO: noindent @@texinfo:@noindent @@
#+MACRO: break @@texinfo:@*@@
#+MACRO: code @@texinfo:@code{@@$1@@texinfo:}@@
